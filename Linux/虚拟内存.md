### 物理和虚拟寻址

计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每个字节都有一个唯一的物理地址(Physical Address,PA),CPU访问内存最自然的方式就是使用物理地址。把这种方式称为物理寻址(physical addressing).

早期的的PC使用物理寻址，诸如数字信号处理器，嵌入式微控制处理器以及Cray超级计算机依然使用这种方式，现代处理器使用是一种称为虚拟寻址(virtual addressing)的寻址方式.

<img src="/Users/zhangchongchong/Library/Application Support/typora-user-images/image-20200918175052272.png" alt="image-20200918175052272" style="zoom:50%;" />

CPU通过生成一个虚拟地址(Virtual Address,VA)来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译(address translation).CPU芯片上叫做内存管理单元(Memory Management Unit,MMU)的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。

### 虚拟内存作为缓存工具

虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都有一个唯一的虚拟地址，作为数组的索引。磁盘上的数据被分割成块，这些块作为磁盘和主存之间的传输单元。VM系统通过将虚拟内存分割为称为虚拟页(Virtual Page,VP)的大小固定的块来处理这个问题，每个虚拟页大小和物理页大小都为P，物理页也被称为页帧(page frame).

在任意时刻，虚拟页面的集合都分为三个不相交的子集：

- 未分配的：VM系统还未分配(或创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。
- 缓存的：当前已缓存在物理内存中的已分配的页
- 未缓存的：未缓存在物理内存中的已分配的页

下图展示了一个有8个虚拟页的小虚拟页的小虚拟内存。虚拟页0和3还没有被分配，因此在磁盘上还不存在。虚拟页1、4、6被缓存在物理内存中。页2、5、7已经被分配了，但是当前并未缓存在主存中。

<img src="/Users/zhangchongchong/Library/Application Support/typora-user-images/image-20200918191400372.png" alt="image-20200918191400372" style="zoom:50%;" />

### DRAM缓存组织结构

SRAM缓存表示位于CPU和主存之间的L1,L2和L3高速缓存，并且用术语DRAM缓存来表示虚拟内存系统的缓存，它在主存中缓存虚拟页。

DRAM比SRAM要慢大约10倍，而磁盘要比DRAM慢大约100 000多倍。因此，DRAM缓存不命中比起SRAM缓存不命中要昂贵得多，这是因为DRAM缓存不命中要由磁盘来服务，而SRAM缓存不命中通常是由基于DRAM的主存来服务的，归根结底，DRAM缓存的组织结构完全是由巨大的不命中开销驱动的。

因为大的不命中处罚和访问第一个字节的开销，虚拟页往往很大，通常是4KB-2MB。由于大的不命中处罚，DRAM缓存是全相联的，即任何虚拟页都可以放置在任何物理页中。不命中时的替换策略也很重要，操作系统对DRAM缓存使用了更复杂精密的替换算法。最后，因为对磁盘的访问时间很长，DRAM缓存总是使用写回，而不是直写。

### 页表

下图展示了一个页表条目(Page Table Entry,PTE)的数组。虚拟地址空间的每个页在页表中一个固定偏移量处都有一个PTE.

<img src="/Users/zhangchongchong/Library/Application Support/typora-user-images/image-20200925200216823.png" alt="image-20200925200216823" style="zoom:50%;" />

VP1、VP2、VP4和VP7当前被缓存在DRAM中。两个页VP0和VP5还未被分配，剩下的VP3和VP6已经被分配了，但是当前还未被缓存

### 页命中

考虑一下当CPU想要读包含在VP2中的虚拟内存的一个字时会发生什么，VP2被缓存在DRAM中。地址翻译硬件将虚拟地址作为一个索引来定位PTE2，并从内存中读取它。因为设置了有效位，那么地址翻译硬件就知道VP2是缓存在内存中的了。所以它使用PTE中的物理内存地址，构造出这个字的物理地址。

### 缺页

在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页(page fault).下图展示了缺页前页表的状态.CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3,从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在PP3中的VP4。如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。

<img src="/Users/zhangchongchong/Library/Application Support/typora-user-images/image-20200925201231756.png" alt="image-20200925201231756" style="zoom:50%;" />

接下来，内核从磁盘复制VP3到内存中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP3已经缓存到主存中了，那么页命中也能由地址翻译硬件正常处理了。

<img src="/Users/zhangchongchong/Library/Application Support/typora-user-images/image-20200925201442928.png" alt="image-20200925201442928" style="zoom:50%;" />

在磁盘和内存之间传送页的活动叫做交换(swapping)或者页面调度(paging)。页从磁盘换入DRAM和DRAM换出磁盘。当有不命中发生时才换入页面的策略称为按需页面调度(demand paging)。也可以采用其他方法，例如尝试预测不命中，在页面实际被引用之前就换入页面。

> 只要我们程序有良好的时间局部性，虚拟内存系统就工作得相当好。如果工作集的大小超出了物理内存的大小，那么程序将处于一种状态叫做抖动(thrashing)，这时页面将不断地换进换出。







