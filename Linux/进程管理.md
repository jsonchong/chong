### 进程

进程就是处于执行期的程序(目标码存放在某种存储介质上)。但进程并不仅仅局限于一段可执行代码。通常进程还要包含其他资源，像打开的文件，挂起的信号，内核内部数据，处理器状态，实际上，进程就是正在执行的程序代码的实时结果。内核需要有效而又透明地管理所有细节。

### 进程描述符及任务结构

内核把进程的列表存放在叫做任务列表(task list)的双向循环链表中。链表中的每一项都是类型为task_struct，称为进程描述符(process descriptor)的结构，该结构定义在<linux/sched.h>文件中，进程描述符中包含一个具体进程的所有信息。

<img src="/Users/zhangchongchong/Library/Application Support/typora-user-images/image-20200918121011958.png" alt="image-20200918121011958" style="zoom:50%;" />

### 分配进程描述符

Linux通过slab分配器分配task_struct结构，这样能达到对象复用和缓存着色，在2.6以前的内核中，各个进程的task_struct存放在它们内核的尾端。这样做是为了让那些像x86那样寄存器少的硬件体系结构只要通过栈指针就能计算出它的位置，而避免使用额外的寄存器专门记录

<img src="/Users/zhangchongchong/Library/Application Support/typora-user-images/image-20200918122412582.png" alt="image-20200918122412582" style="zoom:50%;" />

### 进程描述符的存放

内核通过唯一的进程标识符(process identification value)或PID来标识每个进程。PID是pid_t类型，实际上是一个int,最大默认值是32768(short int的最大值)，这个最大值很重要，实际上就是系统中允许同时存在的进程的最大数目。尽管32768对于一般桌面系统足够用了，但是大型服务器可能需要更多进程。这个值越小，转一圈就越快。

通过current宏查找到当前正在运行进程的进程描述符的速度显得尤为重要。硬件体系结构不同，该宏的实现也不同，它必须针对专门的硬件体系结构做处理。有的硬件体系结构可以拿出一个专门寄存器来存放指向当前进程的task_struct的指针，用于加快访问速度。而有些像x86这样的体系结构(其寄存器并不富余)，就只能在内核栈尾端创建thread_info结构。

### 进程上下文

可执行代码是进程的重要组成部分，这些代码从一个可执行文件载入到进程的地址空间执行，一般程序在用户空间执行。当一个程序执行了系统调用或者触发了某个异常，就陷入了内核空间。此时我们称内核"代表进程执行"并处于进程上下文中。在此上下文中current宏是有效的。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出的时候，程序会恢复在用户空间并继续执行。

### 进程创建

fork()通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于PID,PPID(父进程的进程号)和某些资源和统计量。exec()函数负责读取可执行文件并将其载入地址空间开始运行。

### 写时拷贝

传统的fork()系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不一定共享，Linux的fork()使用写时拷贝(copy-on-write)页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。

只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。这种技术使地址空间上的页拷贝被推迟到实际发生写入的时候才进行。

fork的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。



### fork()

Linxu通过clone()系统调用实现fork().这个调用通过一系列的参数标志来指明父、子进程需要共享的资源。fork(),vfork()和_clone()库函数都根据各自需要的参数标志去调用clone(),然后由clone()去调用do_fork()

do_fork()完成了创建中的大部分工作，它的定义在kernel/fork.c文件中。该函数调用copy_process()函数，然后让进程开始运行。copy_process()函数完成的工作很有意思：

### vfork()

除了不拷贝父进程的页表项外，vfork()系统调用和fork()的功能相同。子进程作为父进程的一个单独的线程在它的地址空间里运行，如果Linux将来fork()有了写时拷贝页表项，那么vfork()就彻底没用了。

vfork()系统调用的实现是通过向clone()系统调用传递一个特殊标志来进行的。

1. 在调用copy_process()时，task_struct的vfor_done成员被设置为NULL.
2. 在执行do_fork()时，如果给定特别标志，则vfork_done会指向一个特定地址。
3. 子进程先开始执行后，父进程不是马上恢复执行，而是一直等待，直到子进程通过vfork_done指针向它发送信号。
4. 在调用mm_release()时，该函数用于进程退出内存地址空间，并且检查vfork_done是否为空，如果不为空，则会向父进程发送信号。
5. 回到do_fork()，父进程醒来并返回。

如果一切顺利，子进程在新的地址空间里运行而父进程也恢复了在原地址空间的运行。这样开销确实降低了，不过它的实现并不是优良的。





















