### GNU C

Linux内核是用C语言编写的，内核并不完全符合ANSI C标准，实际上，内核开发者总是要用到gcc提供的许多语言的扩展部分。

内核开发者使用的C语言涵盖了ISO C99标准和GNU C扩展特性，这其中的种种变化把Linux内核推向了gcc的怀抱。

**内联(inline)函数**

C99和GNU C均支持内联函数，函数会在它所调用的位置展开，这么做可以消除函数调用和返回所带来的开销，不过这么做是有代价的，代码会变长，意味着占用更多的内存空间或者占用更多的指令缓存。**内核开发者通常把那些对时间要求比较高，而本身长度又比较短的函数定义成内联函数。如果一个函数较大，会被反复调用，且没有特别的时间上的限制，我们并不赞成把它做成内联函数。**

定义一个内联函数的时候。需要使用static作为关键字，并且用inline限定它，比如：

```c
static inline void wolf(unsigned long tail_size)
```

在内核中，为了类型安全和易读性，优先使用内联函数而不是复杂的宏

**内联汇编**

gcc编译器支持在C函数中嵌入汇编指令，当然，在内核编程时，只有知道对应的体系结构才能使用这个功能。

我们通常使用asm()指令嵌入汇编代码。例如，下面这条内联汇编指令用于执行x86处理器的rdtsc指令，返回时间戳(tsc)寄存器的值：

```c
unsigned int low,high;
asm volatile("rdtsc" : "=a" (low), "=d" (high));
/*low 和 high分别包含64位时间戳的低32位和高32位*/
```

Linux的内核混合使用了C语言和汇编语言。在偏体系结构的底层或对执行时间要求严格的地方，一般使用的是汇编语言。而内核其他部分的大部分代码是用C语言编写的。

**分支声明**

对于条件选择语句，gcc内建了一条指令用于优化，在一个条件经常出现，或者该条件很少出现的时候，编译器可以根据这条指令对条件分支选择进行优化，比如likely()和unlikey().

```c
if(error){

}
/*我们认为error绝大多数情况不太可能发生*/
if(unlikely(error)){
		...
}
/*认为success通常会发生*/
if(likely(success)){

}
```

如果你的判断正确，确实这个条件占压倒性的优势，那么性能会得到提升，反之会下降

**没有内存保护机制**

如果是内核自己非法访问了内存，后果就很难控制了，内核中发生的内存错误会导致oops,这是内核中出现的最常见的一类错误。在内核中，不应该去做访问非法的内存地址，引用空指针之类的事情，否则它可能会死掉却根本不告诉你一声

**不要轻易在内核中使用浮点数**

即使CPU带有浮点数运算部件，一般内核还是要避免直接进行浮点数运算，因为这些部件有可能被用户进程占用了，内核要判断这些浮点数部件是否被占用，保护现场，然后用浮点运算部件计算结果，恢复现场，开销会很大。如果CPU不支持浮点数运算，也就只能软件实现浮点数运算，要是你设计内核的话，你情愿避免这个问题还是多做额外功夫(写浮点数实现代码)并且使得内核的效率不高呢？









