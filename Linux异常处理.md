### 异常

异常是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现

异常就是控制流中的突变，用来响应处理器状态中的某些变化

<img src="/Users/zhangchongchong/Library/Application Support/typora-user-images/image-20200521152403757.png" alt="image-20200521152403757" style="zoom:50%;" />

在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表(exception table)的跳转表，进行一个间接过程调用(异常),到一个专门设计用来处理这类事件的操作系统子程序(异常处理程序(exception handler)。当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下几种情况的一种：

1. 处理程序将控制返回给当前指令Icurr,即当事件发生时正在执行的指令
2. 处理程序将控制返回给Inext,如果没有发生异常将会执行的下一条指令
3. 处理程序终止被中断的程序

### 异常处理

系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号(exception number)。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核(操作系统常驻内存部分)的设计者分配的。前者的示例包括被零整除，缺页，内存访问违例，断点以及算术运算溢出。后者的示例包括系统调用和来自外部I/O设备的信号。

#### 中断

中断时异步发生的，是来自处理器外部的I/O设备信号的结果。硬件中断不是由任何一条专门指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为中断处理程序(interrupt handler).

例如网络适配器，磁盘控制器和定时器芯片，通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。

![image-20200521173948343](/Users/zhangchongchong/Library/Application Support/typora-user-images/image-20200521173948343.png)

在当前指令完成执行之后，处理器注意到中断引脚的电压变高了，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，它就将控制返回给下一条指令。

#### 陷阱和系统调用

陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。

用户程序经常需要向内核请求服务，比如读一个文件(read),创建一个新的进程(fork)，加载一个新的程序(execve),或者终止当前进程(exit)。为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的"syscall n"的指令，当用户程序想要请求服务n时，可以执行这条指令。执行syscall指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。

![image-20200521175926996](/Users/zhangchongchong/Library/Application Support/typora-user-images/image-20200521175926996.png)

系统调用和普通的函数调用是一样的，然而，它们的实现非常不同。普通的函数运行在用户模式中，用户模式限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。系统调用运行在内核模式中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈

#### 故障

故障由错误情况引起，当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，abort例程

![image-20200521184722959](/Users/zhangchongchong/Library/Application Support/typora-user-images/image-20200521184722959.png)

一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。一个页面就是虚拟内存的一个连续的块(4KB)。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中了，指令就可以没有故障地运行完成了。

