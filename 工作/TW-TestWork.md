## 应用架构

### 背景

Wxx是公司级移动办公产品，由于融合了邮件，IM，通讯录，视频会议，直播，审批等多种业务场景，且每天使用量频繁，研发团队逐渐扩大，独立的业务团队也逐渐细分，多样。

### 存在的问题

各个业务团队开发协作效率低下，经常出现代码冲突，依赖管理混乱，导致整个需求迭代的周期缓慢，不可控。

### 改善方案

必须要对业务进行隔离，同时沉淀出通用组件，完善移动开发的基础设施。

**划分各个业务模块的边界**

**业务边界不清晰**最直观的表现是开发新功能后容易引入新的bug，破坏其他的业务模块的执行流程，不能从根本上解决bug,维护成本比较高，同时对于测试也非常不友好，回归测试范围不可控。

从工程化的角度来看，业务和团队的快速发展也会带来巨大的挑战，

所以我们需要一个灵活开放的架构来支撑多团队多业务的快速协同开发，需要建立超级 App 的运维体系。

从下到上，分别是「容器层、组件层、框架层、服务层和应用层」 以下是app未来最终的演进架构

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6t4h526vj30xm0q2dkn.jpg" alt="image-20200728142641220" style="zoom:50%;" />

- **容器层：**最底层的基础层，管理这每个模块 bundle 的加载和资源的处理，如插件化框架
- **组件层：**是抽离出来的通用组件，提供一些通用能力，比如网络、缓存、日志、图像加载，UI上如通用列表组件等
- **框架层：**这层和原生的 Android,iOS 系统 SDK 类似，是定制的用来做每个模块 bundle 之间解耦、交互和通信的基础层，有 Native,H5 和 Google的Flutter或者FaceBook的ReactNative等
- **服务层：**基于框架封装的一些业务服务层，提供登录、注册、直播，IM 等服务
- **应用层**：即用户可见的具体业务，比如请假审批流程，邮件收发功能，查看联系人等

这样架构的好处是，如果未来衍生多个产品或者独立的业务模块都可以采取类似的结构，因为是同样的架构底层，同一个业务很方便的做迁移

同时做到模块/组件可插拔，可动态发布，每个模块可由独立的团队或个人维护，且模块与模块之间很好的解耦，互不影响。

总体来说，各个业务线可以并行开发，互相不影响，谁的版本有问题，可以随时回滚到稳定版本，模块或者组件之间的交互通过定制的框架层来通信，同样也可以很方便地增加一块新的模块或组件，自由扩展业务。

具体方案：

比如在Android平台可以参照阿里巴巴开源的Atlas组件框架https://alibaba.github.io/atlas/

Atlas是伴随着手机淘宝的不断发展而衍生出来的一个运行于Android系统上的一个容器化框架，我们也叫动态组件化(Dynamic Bundle)框架。它主要提供了解耦化、组件化、动态性的支持。覆盖了工程师的工程编码期、Apk运行期以及后续运维期的各种问题。

IOS可参照同样是阿里巴巴的IOS模块化框架BeeHive https://github.com/alibaba/BeeHive/

总结：各业务线的开发和集成都需要到一个宿主工程上，在业务间相互耦合严重，集成开发工作效率低下这样的背景下。急需要做一次从构建、集成、交付的技术改造。从应用架构上的重构和演进来支撑后续的测试，部署，交付等流程上的优化。

## 测试方案

### 1. 代码静态检查

代码静态检查，即静态代码分析，是**指不运行被测代码，仅通过分析或检查源程序的语法、结构、过程、接口等检查程序的正确性，并找出代码中隐藏的错误和缺陷**（比如参数不匹配、有歧义的嵌套语句、错误的递归、非法计算、可能出现的空指针引用等等）。

> 在软件开发的过程中，静态代码分析往往在动态测试之前进行，同时也可以作为设计动态测试用例的参考。有统计数据证明，在整个软件开发生命周期中，有 70% 左右的代码逻辑设计和编码缺陷属于重复性错误，完全可以通过静态代码分析发现和修复。

### 静态检查工具的优势

主要包括以下三个方面：

1. 帮助软件开发人员自动执行静态代码分析，快速定位代码的隐藏错误和缺陷
2. 帮助软件设计人员更专注于分析和解决代码设计缺陷；
3. 显著减少在代码逐行检查上花费的时间，提高软件可靠性的同时可以降低软件测试成本。

SonarQube 是一款目前比较流行的工具，国内很多互联网公司都选择用它来搭建静态检查的平台。

SonarQube 采用的是 B/S 架构，通过插件形式，可以支持对 Java、C、C++、JavaScript 、swift等二十几种编程语言的代码质量管理与检测。

Sonar 通过客户端插件的方式分析源代码，可以采用 IDE 插件、Sonar-Scanner 插件、Ant 插件和 Maven 插件等，并通过不同的分析机制完成对项目源代码的分析和扫描，然后把分析扫描的结果上传到 Sonar 的数据库，之后就可以通过 Sonar Web 界面管理分析结果。

### 检查流程

1. 鼓励开发人员在开发环境（不管是 IDE 还是编辑器加命令行）下执行静态检查；
2. 不管采用的是主干开发还是特性分支开发的分支策略，都尽可能地在代码合入主干之前，通过静态检查；
3. 没有通过静态检查的产品包，不允许发布到线上或用户验证环境。

### 如何提高静态检查的效率？

**除了提升静态检查平台的处理能力外，在代码合入主干前采用增量形式的静态检查**，也可以提升整个静态检查的效率。增量静态检查，是指只对本次合入涉及的文件做检查，而不用对整个工程做全量检查。

### 如何制定规则？

1. 从已有的规则集合中挑选团队适用的规则，必要情况下调整规则的严重等级和部分参数
2. 基于某个规则框架，编写全新的规则。这种方式需要自行编码，难度成本较大，一般不推荐采用，确实找不到现成的规则时再采用这种方案。



### 2. 自动化测试框架

对 Native App 的测试，虽然不同的平台会使用不同的自动化测试方案（比如，iOS 一般采用 XCUITest Driver，而 Android 一般采用 UiAutomator2 或者 Espresso 等）。数据驱动、页面对象以及业务流程封装的思想可以把这些方法应用到测试用例设计中。

### 自动化测试框架的设计思路

Appium一个开源、跨平台的测试框架，可以用来测试原生及混合的移动端应用。Appium支持iOS、Android及FirefoxOS平台测试。Appium使用WebDriver的json wire协议，来驱动Apple系统的UIAutomation库、Android系统的UIAutomator框架。
相比其他的移动自动化测试工具，Appium测试由于调用了Selenium的client库使其可以使用任意的语言，包括Python、Ruby、Node.js、Objective-C等。

**测试框架分层: **基于UI测试，希望除了支持web测试，还能支持app的测试，可能还需要接口测试，就需要考虑分层问题，将测试框架分为三层。上层是管理整个自动化测试的开发，执行以及维护，在比较庞大的项目中，它体现重要的作用，它可以管理整个自动测试，包括自动化测试用例执行的次序、测试脚本的维护、以及集中管理测试用例、测试报告和测试任务等。下层主要是测试脚本的开发，充分的使用相关的测试工具，构建测试驱动，并完成测试业务逻辑。

**第一层：数据层**: 即执行用例时所需要的测试数据，如商户名、空间名、URL等，这些数据用来支撑整个脚本的执行。

**第二层：驱动层**: 这一层主要封装各种driver。比如我们针对网页测试，使用selenium-webdriver开发包，针对app测试，我们使用appium开发包。我们在这一层进行封装，通过调用selenium-webdriver，appium提供的原生方法，封装成可读性很强的方法

**第三层：测试案例层**: 该层是测试案例的具体实现。

**第四层：结果保存层**：将测试脚本的日志和结果以自定义的方式展示，使用ReportNG,它可以丰富测试结果的展现形式，帮助团队更快定位和解决问题。

**将构建加入自动化测试**：无论任何时候，只要代码更新提交到git中，构建服务器就会触发一个构建，构建运行脚本去编译应用程序并且运行一系列的自动化单元测试和/或集成测试。通过自动化测试结果能够清晰的展示出那些功能特性是通过的，哪些是失败的。测试报告的发送可以结合Jenkins来实现，通过简单的配置即可实现。

### 3.  移动应用专项测试

也许自动化测试框架能顺利完成制定的各种测试用例，那么，当你的移动应用被大量用户安装和使用时，就会暴露出很多之前完全没有预料到的问题。比如

- 流量使用过多；
- 耗电量过大；
- 在某些设备终端上出现崩溃或者闪退的现象；
- 多个移动应用相互切换后，行为异常；
- 在某些设备终端上无法顺利安装或卸载；弱网络环境下，无法正常使用；

**第一，交叉事件测试**：

交叉事件测试也叫中断测试，是指 App 执行过程中，有其他事件或者应用中断当前应用执行的测试。比如，App 在前台运行过程中，突然有电话打进来，或者收到短信，再或者是系统闹钟等等情况。

**第二，兼容性测试**：

要确保 App 在各种终端设备、各种操作系统版本、各种屏幕分辨率、各种网络环境下，功能的正确性。常见的 App 兼容性测试往往需要覆盖以下的测试场景：

- 不同操作系统的兼容性，包括主流的 Andoird 和 iOS 版本
- 主流的设备分辨率下的兼容性
- 主流移动终端机型的兼容性
- 不同网络连接下的兼容性，比如 Wifi、GPRS

兼容性测试，通常都需要在各种真机上执行相同或者类似的测试用例，可以搭建自己的移动设备私有云平台，同时也可以接入第三方的云测试平台来完成自动化的兼容性测试（Testin）

**第三，流量测试**： 

- App 在后台运行时的消耗流量
- App 安装包本身的大小
- App 执行业务操作引起的流量

可以利用 tcpdump、Wireshark 和 Fiddler 等网络分析工具。

**第四，耗电量测试**：

在目前的生态环境下，能提供类似服务或者功能的 App 往往有很多，如果在功能类似的情况下，你的 App 特别耗电、让设备发热比较严重，那么你的用户一定会卸载你的 App 。

- App 运行但没有执行业务操作时的耗电量；
- App 运行且密集执行业务操作时的耗电量；
- App 后台运行的耗电量。

**第五，边界测试**：

- 系统内存占用大于 90% 的场景
- App 不具有某些系统访问权限的场景，比如 App 由于隐私设置不能访问相册或者通讯录等
- 长时间使用 App，系统资源是否有异常，比如内存泄漏、过多的链接数等
- 出现 ANR 的场景；

另外关于性能如耗电量，内存问题等测试监控可以由开发人员接入或者参照第三方的一些开源框架引入，类似的有360 移动 App 性能监控平台 ArgusAPM，*https://github.com/Qihoo360/ArgusAPM*

ArgusAPM是360移动端产品使用的可视化性能监控平台，为移动端APP提供性能监控与管理，可以迅速发现和定位各类APP性能和使用问题，帮助APP不断的提升用户体验。

这类性能监控框架的引入除了在开发测试阶段能够提前暴露问题，同时还可以在线上环境通过生成日志，比如当某个性能指标接近阈值便生成当前环境上下文，如堆栈信息，操作链路，相关模块等，在合适的时间上报，最终在线上后台监控中观测线上用户的性能指标定位相关业务模块。

## 代码管理

### 代码分支管理

GitHub Flow 是 GitHub 所使用的一种简单流程。该流程只使用 master 和特性分支，并借助 GitHub 的 pull request 功能。master 分支中包含稳定的代码，它已经或即将被部署到生产环境。任何开发人员都不允许把未测试或未审查的代码直接提交到 master 分支。对代码的任何修改，包括 Bug 修复、热修复、新功能开发等都在单独的分支中进行。不管是一行代码的小改动，还是需要几个星期开发的新功能，都采用同样的方式来管理。

当需要修改时，从 master 分支创建一个新的分支，所有相关的代码修改都在新分支中进行。开发人员可以自由地提交代码和提交到远程仓库。

当新分支中的代码全部完成之后，**通过 GitHub 提交一个新的 pull request。团队中的其他人员会对代码进行审查，提出相关的修改意见。由持续集成服务器（如 Jenkins）对新分支进行自动化测试。当代码通过自动化测试和代码审查之后，该分支的代码被合并到 master 分支**。再从 master 分支部署到生产环境

由于刚才在应用架构中提到应用的组件化方案，通过组件化带来的好处可以在代码管理和项目依赖中优化：

1. **方便拆分代码仓库，降低分支管理难度，提高开发并行度。**如果一个巨大的 App 的所有代码都集中在同一个代码仓库中，而所有的并行开发功能又都会形成一个个的功能分支的话，它们之间相互的影响将是难以想象的。所以，对整个项目进行解耦，把不相干的功能组件从代码仓库这个层面进行隔离，以免互相影响。
2. **组件可以多版本存在，通过依赖快速选取所需版本。**所有的组件都可以同时发布多个版本，发布的形式可以是代码包、二进制组件等等。这样做的好处是，对于组件的提供方和依赖方来说，只需要通过版本控制就能管理或者选取自己需要的组件功能，降低了减少沟通成本。
3. **专业分工。**一旦实施组件化，各种更专业的通用组建会慢慢形成（比如网络处理、图片处理、语音处理等等），而这些更专业的组件，也会渐渐地由更专业的人或团队进行开发和维护，专业的分工使得研发效率得到进一步提升。所以，组件化其实就是通过专业分工，提升了整个组织的开发效率

## 构建优化

在实施持续交付的过程中，我们经常会遇到这样的情况：只是改了几行代码，却需要花费几分钟甚至几十分钟来构建，是难以容忍的。

### 升级硬件资源

构建是一个非常耗时的操作，常常会成为影响持续交付速度的瓶颈。原因是，构建过程，会直接消耗计算资源，而且很多构建对硬件的要求也非常高。

比如，你要用 Maven 构建一个 Java 应用，除了 CPU 之外，Maven 还会从中央仓库下载依赖写在本地磁盘。**这时，网络和磁盘的 I/O 就可能成为瓶颈，你可以通过增加网络带宽提升网络吞吐，使用 SSD 代替机械硬盘增加磁盘 I/O**

### 搭建私有仓库

构建很多时候是需要下载外部依赖的，而网络 I/O 通常会成为整个构建的瓶颈。尤其在当前网络环境下，从外网下载一些代码或者依赖的速度往往是瓶颈，所以在内网搭建各种各样的私有仓库就非常重要了。

- 使用 Nexus 搭建 Java 的 Maven 仓库；
- 使用 cnpm 搭建 NodeJS 的 npm 仓库；

为了解决组件依赖的问题，你需要特别准备独立的中央组件仓库，并用缓存等机制加快依赖组件下载的速度

### 组件依赖问题

可以从**扁平化依赖管理和二进制交付**两个维度解决。

#### 第一，扁平化依赖管理

由传递依赖带来的不确定性，是我们经常会遇见并非常讨厌的组件依赖形式。因为发现和处理的成本都很高。

一个移动 App 可以拆分出十几到几十个组件，甚至可以拆分出几百个组件。要保证这么多组件间依赖传递的准确性，其难度非常大。所以，为了解决这个问题，**业界现在普遍直接采用扁平化的依赖管理方式，减少甚至去除传递依赖，以此避免组件、版本冲突的问题。**

#### 第二，二进制交付

传统的组件先以源码的方式集成到目标项目，然后对整个项目进行编译。如果组件比较多的话，采用这种方式的编译时间会非常长。有时，甚至要编译 1 个多小时。

使用二进制包的方式，可以帮我们大幅提升移动 App 的编译速度。而且，因为有了中间交付物，在本地缓存需要依赖的组件，进一步加速编译过程。

## 发布管理

### 发布快车模式

就像一列由多节车厢组成的火车，每一节车厢代表一个发布版本，整个火车以一节节车厢或者说一个个版本的节奏，定期向前发车。而工程师们，则会把自己开发完成的功能集成到一节节的车厢上，这样集成在一节车厢的功能代码，就形成了一个新的版本

**第一个关键点是**。任何功能都应该按照既定计划，规划纳入到适合的那节车厢、那个版本中。

**第二个关键点是，我们必须要保证固定间隔的发车时间，每周、每两周都可以，但必须保证每个车厢到点即发。**只有这样，我们才能保证持续交付流水线的持续运行，以及不间断地产出。这里需要注意的是，对于一些特殊的、不规则的发布，我们要把它们归类到热修复的流程，而不是在发布快车中处理。

**第三个关键点是，这个过程的最终产物是可以发布到市场的版本。**虽然这个发布模式叫作发布快车，但其实它的最终产物是可以发布的待发布版本。

以上说的三个特性，非常符合移动 App 对持续交付的需求，即：分散开发，定期集成，控制发布。所以绝大部分的移动 App 团队，都选择采用发布快车的发布方式。

在功能分支合并入 Master 分支前，增加一次构建（Merge CI Service），这次构建的作用是保证功能分支的集成是成功的，否则不允许合并；同时，对于一个代码仓库来说，增加的这次构建过程要保证是串行的

这个合并构建过程，保证了 Master 分支上的任何 commit 随时都可以成功构建。之后再根据发布快车的要求定期启动版本构建（Auto CI Service），就能顺利地得到可测试版本了。

### 自动化的发布

- OS 系统的发布步骤为：构建，导出 ipa 包，记录符号表，备份，上传至 iTC；
- Android 系统的发布步骤为：构建打包，更新渠道标识，签名，保存 mapping 文件，备份，上传至发布点

比如，针对 iOS 的版本发布来说，在构建和打包之后，我们可以获取到对应的 ipa 包，关联对应的版本信息元数据后，就可以上传到内部的发布站点，供 QA 下载测试了；或者上传到 Apple TestFlight 进行公测；当然也可以部署到 App Store 了。

你可以使用 Fastlane 等类似的工具完成整个发布过程，还可以根据不同发布的渠道定义各自的 lane。当然 Fastlane 也可以提供打包等一系列 Action，帮助你完成自动化

可以按照发布流程的需求定义自己的 lane 和 Action，完成不同的操作

```shell
private_lane :build do |options|
    project = options[:project] #获取项目对象
    build_number = project.build_number #获取项目定义的版本号
    gym(
  workspace: project.workspace, #编译工作空间
  configuration: project.config, #编译配置
  include_symbols: true, #是否包含符号
  scheme: project.scheme, #编译计划
  xcargs: "BUILD_NUMBER=#{build_number}", #版本号
  build_path: project.package_path, #编译路径
  output_directory: project.package_path, #ipa包输出地址
  output_name: project.ipa_name, #ipa包的名字
  silent: false) # 编译Action
end
```

### 发布平台架构

没有统一的管理规范流程，非常容易因为操作错误造成事故。

统一发布平台需要集中管理应用所有的数据下发业务，并建立严格规范的灰度发布流程

**管理: **所有的发布都必须通过权限校验，需要经过审批。“谁发布，谁负责”，需要建立严格的事故定级制度。对于因为疏忽导致事故的人员，需要定级处理

**灰度: **所有的发布一定要经过灰度测试，慢慢扩大影响的用户范围

**监控: **统一发布平台需要对接应用的“实时数据平台”，在出现问题的时候，需要及时采取补救措施。

## 线上监控

**第一，用户侧监控**

监控数据既可以通过打点的方式，也可以通过定期回收日志的方式收集。

1. 端到端的监控，主要包括包括一些访问量、访问成功率、响应时间、发包回包时间等监控指标。同时，我们可以从不同维度定义这些指标，比如：地区、运营商、App 版本、返回码、网络类型等等。
2. 移动端的日志。我们除了关注系统运行的日志外，还会关注系统崩溃或系统异常类的日志，以求第一时间监控到系统故障。
3. 设备表现监控，主要指对 CPU、内存、温度等的监控，以及一些页面级的卡顿或白屏现象；或者是直接的堆栈分析等
4. 唯一用户 ID 的监控。除了以上三种全局的监控维度外，用户侧的监控一定要具备针对唯一用户 ID 的监控能力，能够获取某一个独立用户的具体情况。

**第二，业务监控**

任何的系统故障或问题，影响最大的就是业务指标。因此，监控企业的核心业务指标，能够以最快的速度反应系统是否稳定。 反之，如果系统故障或问题并不影响核心业务指标，那么也就不太会造成特别严重的后果

**第三，系统监控**

系统监控，指的是对基础设施的监控。我们通常会收集 CPU、内存、I/O、磁盘、网络连接等作为监控指标。对于系统监控的指标，我们通常采用定期采样的方式进行采集，一般选取 1 分钟、3 分钟或 5 分钟的时间间隔，但一般不会超过 5 分钟，否则监控效果会因为间隔时间过长而大打折扣。

最后需要建立一套完整的运维事件记录体系，并将发布纳入其中，记录所有的运维事件。当有异常情况时，你可以根据时间线进行相关性分析





