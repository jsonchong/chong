与后端服务相比，移动 App 的出现和工程方面的发展时间都较短，所以大部分持续交付的流程和方法都借鉴了后端服务的持续交付。但是，移动 App 因为其自身的一些特点，比如版本更新要依赖用户更新客户端的行为等，所以移动 App 的持续交付也呈现了一些独有的特点。

同时，移动 App 的持续交付也存在一些痛点

比如，移动 App 的编译速度，也随着应用越来越大变得越来越慢；再比如，Apple Store 审核慢、热修复困难等问题。

### 代码及依赖管理

对于移动 App 来说，业界流行的做法是采用“分支开发，主干发布”的方式，并且采用交付快车的方式进行持续的版本发布。

**其次，移动 App 的开发已经走向了组件化，所以也需要处理好依赖管理的问题。**

移动端的技术栈往往要比统一技术栈的后端服务更复杂，所以在考虑依赖管理时，我们需要多方位地为多种技术栈做好准备。比如：

针对 Android 系统，业界通常使用 Gradle 处理依赖管理的问题。Gradle 是一个与 Maven 类似的项目构建工具。与 Maven 相比，它最大的优点在于使用了以 Groovy 为基础的 DSL 代替了 Maven 基于 XML 实现的配置脚本，使得构建脚本更简洁和直观。

针对 iOS 系统，我们则会使用 CocoaPods 进行依赖管理。它可以将原先庞大的 iOS 项目拆分成多个子项目，并以二进制文件的形式进行库管理，从而实现对 iOS 的依赖管理。另外，这种管理依赖的方式，还可以提高 iOS 的构建速度。

除了以上两个技术栈外，移动 App 还会涉及到 H5、Hybrid 等静态资源的构建、发布和管理。那么同样的，我们也就需要 Nexus、npm 等构建和依赖管理工具的辅助。

### 项目信息管理

**对于移动 App 的持续交付来说，我们特别需要维护版本的相关信息，并对每个版本进行管理。**

对后端服务来说，它只要做到向前兼容，就可以一直以最新版本的形式进行发布；而且，它的发布相对自主，控制权比较大。

但对移动 App 来说，情况则完全不同了：一方面，它很难保证面面俱到的向前兼容性；另一方面，它的发布控制权也没那么自主，要受到应用商店、渠道市场和用户自主更新等多方面因素的影响。

另外，为了提高移动 App 的构建和研发效率，我们会把整个项目拆分多个子项目，而主要的拆分依据就是功能模块。也就是说，除了从技术角度来看，移动 App 的持续交付会存在依赖管理的内容外，从项目角度来看，也常常会存在功能依赖和功能集成的需要。所以，**为了项目的协调和沟通，我们需要重点管理每个功能的信息**。

可见，**做好项目信息管理在移动 App 的持续交付中尤为重要**，而在后端服务的持续交付中却没那么受重视了，这也是移动 App 的持续交付体系与服务端的一大不同点。以携程或美团点评为例，它们都各自研发了 MCD 或 MCI 平台，以求更好地管理项目信息。

### 静态代码检查

静态代码检查的内容，就和后端服务比较相似了。为了提高移动端代码的质量，业界也陆续提供了不少的静态代码检查方案。比如：

- Clang Static Analyzer，被 Xcode 集成，但其缺乏代码风格的检查，可配置性也比较差
- OCLint，其检查规则更多，也更易于被定制；
- Infer，是 Facebook 提供的一款静态检查工具，具有大规模代码扫描效率高、支持增量检查等特点。

### 构建管理

移动 App 构建管理的大体流程，我们可以借鉴后端服务的做法，即：通过代码变更，触发自动的持续集成。集成过程基本遵循：拉取代码、静态检查、编译构建、自动化测试，以及打包分发的标准过程。

1. **你需要准备 Android 和 iOS 两套构建环境**，而且 iOS 的构建环境还需要一套独立的管理方案。因为，iOS 的构建环境，你不能直接使用 Linux 虚拟机处理，而是要采用 Apple 公司的专用设备。
2. 在整个构建过程中，你还要考虑证书的管理，不同的版本或使用场景需要使用不同的证书。如果证书比较多的话，还会涉及到管理的逻辑问题，很多组织都会选择自行开发证书管理服务。
3. 为了解决组件依赖的问题，你需要特别准备独立的中央组件仓库，并用缓存等机制加快依赖组件下载的速度

### 发布管理

**首先，移动 App 无法做到强制更新**，决定权在终端用户。移动 App 的发布，你所能控制的只是将新版本发布到市场而已，而最终是否更新新版本，使得新版本的功能起效，则完全取决于用户。

**其次，移动 App 在正式发布到市场前，会进行时间比较长的内测或公测。**这些测试会使用类似 Fabric Beta 或者 TestFlight 这样的 Beta 测试平台，使部分用户优先使用，完成灰度测试；或者在公司内部搭建一个虚拟市场，利用内部资源优先完成内测。而且，这个测试周期往往都比较长，其中也会迭代多个版本。

**最后，移动 App 的分发渠道比较多样。**还可能会利用一些特殊的渠道进行发布。为了应对不同的渠道的需求，比如标准渠道版本，控制部分内容，一些字样的显示等等。在完成基本的构建和打包之后，还需要做一些额外的配置替换、增删改查的动作。比如，更新渠道配置和说明等。

### 运营管理

移动 App 发布之后，还有一件比较重要的事项，那就是对每个版本的运营管理。这里讲的运营主要是指，追踪、分析和调优这个版本发布的表现和反馈。我们运营时，主要关注的内容包括：奔溃报告、区域分析、用户分析、系统资源消耗、流量消耗、响应时长、包体大小、系统监控，以及预警等。

### 热修复

移动 App 的发布需要用户安装才能起效，这就决定了它不能采用后端服务修复 Bug 的方式。因为，这会要求用户在很短的时间内重新安装客户端，这样的用户体验相当糟糕。但是，我们也无法避免 Bug。所以，对移动 App 来说，我们就要通过特定的热修复技术，做到在用户不重新安装客户端的前提下，就可以修复 Bug。这也就是我所说的热修复。

关于热修复，比如 **Android 系统**，主要的方式就是以下两步：

1. 下发补丁（内含修复好的 class）到用户手机
2. App 通过类加载器，调用补丁中的类

其实现原理，**主要是利用了 Android 的类加载机制，即从 DexPathList 对象的 Element 数组中获取对应的类进行加载，而获取的方式则是遍历。也就是说，我们只需要把修复的类放置在这个 Element 数组的第一位就可以保证加载到新的类**，而此时有 Bug 的类其实还是存在的，只是不会被加载到而已。

**iOS 系统方面**，Apple 公司一直对热修复抓的比较严。但是，从 iOS7 之后，iOS 系统引入了 JavaScriptCore，这样就可以在 Objective-C 和 JavaScript 之间传递值或对象了，从而使得创建混合对象成为了可能。因此，业界产生了一些成熟的热修复方案。比如：

1. Rollout.io、JSPatch、DynamicCocoa这三个方案，只针对 iOS 的热更新。目前，Rollout.io 和 JSPatch 已经实现了平台化，脚本语言用的都是 JavaScript。Rollout.io 除了支持 OC 的热更新外，还支持 Swift。DynamiCocoa 源自滴滴，目前还没开源，所以我也没怎么体验过。但是，它号称可以通过 OC 编码，自动转换成 JavaScript 脚本，这对编码来说好处多多。

2. React Native、Weex这两个方案，都是跨平台的热更新方案。其中，React Native 是由 Facebook 开发的， Weex 是由阿里开发的。就我个人的体验来说，Weex 从语法上更贴近编程思路，而且还实现了平台化，使用起来更加便捷。
3. Wax 、Hybrid这两个方案，比较特殊。其中，Wax 采用的脚本语言是 Lua 而不是 JavaScript，所以比较适用于游戏；而 Hybrid 主要面向 H5，Hybrid App 已经被证明不是好的方案，所以用户越来越少了。

### 发布快车模式

顾名思义，发布快车，就像一列由多节车厢组成的火车，每一节车厢代表一个发布版本，整个火车以一节节车厢或者说一个个版本的节奏，定期向前发车。而工程师们，则会把自己开发完成的功能集成到一节节的车厢上，这样集成在一节车厢的功能代码，就形成了一个新的版本。

<img src="https://static001.geekbang.org/resource/image/c8/d2/c802a0f8f0cf4e57e4854b4e227918d2.png" alt="img" style="zoom:50%;" />

**第一个关键点是，并不是说所有开发的功能，都一定要集成到最近的那节车厢、最近的那个版本中**。任何功能都应该按照既定计划，规划纳入到适合的那节车厢、那个版本中。这也是为什么移动端 App 的持续交付需要良好的信息管理的原因。

**第二个关键点是，我们必须要保证固定间隔的发车时间，每周、每两周都可以，但必须保证每个车厢到点即发。**只有这样，我们才能保证持续交付流水线的持续运行，以及不间断地产出。这里需要注意的是，对于一些特殊的、不规则的发布，我们要把它们归类到热修复的流程，而不是在发布快车中处理。

**第三个关键点是，这个过程的最终产物是可以发布到市场的版本，而不是发布到用户侧的版本。**虽然我们把这个发布模式叫作发布快车，但其实它的最终产物是可以发布的待发布版本。所以这个流程完成后的版本没有被正式发布，或出现了部分缺陷无法发布的情况是很正常的，可以被接受。我们并不需要保证每个版本都一定能发布到用户手上。

发布快车的发布模式，特别是以上说的三个特性，非常符合移动 App 对持续交付的需求，即：分散开发，定期集成，控制发布。所以绝大部分的移动 App 团队，都选择采用发布快车的发布方式。

如何才能实现这个发布快车模式的真实落地呢？

1. 选择与发布快车模式匹配的代码分支策略；
2. 改造出与发布快车模式匹配的构建通道；
3. 实现发布流程的全自动化。

### 选择与发布快车模式匹配的代码分支策略

Gitlab Flow 与 发布快车模式的思想看上去非常接近。那我们不妨推演一下，这个分支策略是否符合我们的需要。

首先，项目仓库的初始状态如图 2 所示。这里有一个版本 V1，代码仓库中有 2 个分支：Master，是集成分支；Production，是发布分支。

<img src="https://static001.geekbang.org/resource/image/ad/9c/adc587c19ca50248a589639e3439019c.png" alt="img" style="zoom:50%;" />

然后，以 V1 的 commit 为基准，建立功能分支 1，并进行开发

<img src="https://static001.geekbang.org/resource/image/00/24/006d004b8f4c2fa2d12451ff2de76524.png" alt="img" style="zoom:50%;" />

功能分支 1 开发完成后，合并入 Master。测试通过之后形成版本 V2，V2 就可以作为待发布的产物了。另外，在形成 V2 之前，我们可以看到，另外一个功能分支 2 也被建立了，但这个功能分支并没有被合并到 Master，所以不会出现在版本 V2 中。

<img src="https://static001.geekbang.org/resource/image/78/cb/789bece7976130a9722a0ca90acccbcb.png" alt="img" style="zoom:50%;" />

V2 版本后，又出现了一个新的功能分支 3，它与功能分支 2 并行开发。这两个功能分支合并入 Master 之后，被同时附加到版本 V3 中。

<img src="https://static001.geekbang.org/resource/image/df/45/dfb010fd678e02dc9065659657c6c745.png" alt="img" style="zoom:50%;" />

正如以上的几个步骤，如果每个版本都是定时进行构建和打包，那么这样的代码分支管理模型就是一个典型的符合发布快车的物理实现了。

### 全新的构建通道

当然，为了发布快车模式的落地，我们只是建立与之配套的代码分支管理策略还远远不够，还需要有配套的构建通道。

我们会在功能分支合并入 Master 分支前，增加一次构建（Merge CI Service），这次构建的作用是保证功能分支的集成是成功的，否则不允许合并；同时，对于一个代码仓库来说，增加的这次构建过程要保证是串行的

这个合并构建过程，保证了 Master 分支上的任何 commit 随时都可以成功构建。之后再根据发布快车的要求定期启动版本构建（Auto CI Service），就能顺利地得到可测试版本了。

构建测试版本之后，流水线还可以继续处理，在 production 分支上打上对应的 tag。

### 自动化的发布

1. 通常在发布到市场之前，会先发布内部，进行针对新功能的内测；
2. 通常，为了节省调试信息带来的额外开销，内部发布会采用 debug 包，而正式发布则采用 release 包。

- iOS 系统的发布步骤为：构建，导出 ipa 包，记录符号表，备份，上传至 iTC；
- Android 系统的发布步骤为：构建打包，更新渠道标识，签名，保存 mapping 文件，备份，上传至发布点

比如，针对 iOS 的版本发布来说，在构建和打包之后，我们可以获取到对应的 ipa 包，关联对应的版本信息元数据后，就可以上传到内部的发布站点，供 QA 下载测试了；或者上传到 Apple TestFlight 进行公测；当然也可以部署到 App Store 了。

你可以使用 Fastlane 等类似的工具完成整个发布过程，还可以根据不同发布的渠道定义各自的 lane。当然 Fastlane 也可以提供打包等一系列 Action，帮助你完成自动化。

```shell

lane :release do #发布到AppStore
  increment_build_number  #自增版本号的方法
  cocoapods #更新pod
  gym #打包 
  deliver(force: true) #发布到AppStore
end  
```

这是一段最简单的 Fastfile 脚本。它的功能是：利用 Fastlane 提供的 Action 完成了打包，并发布到 AppStore。另外，你还可以在 Appfile（Fastlane 用来描述 App 基本信息的专用描述文件）中定义关于 App 的信息。

当然，你还可以按照发布流程的需求定义自己的 lane 和 Action，完成不同的操作

```shell

private_lane :build do |options|
    project = options[:project] #获取项目对象
    build_number = project.build_number #获取项目定义的版本号
    gym(
  workspace: project.workspace, #编译工作空间
  configuration: project.config, #编译配置
  include_symbols: true, #是否包含符号
  scheme: project.scheme, #编译计划
  xcargs: "BUILD_NUMBER=#{build_number}", #版本号
  build_path: project.package_path, #编译路径
  output_directory: project.package_path, #ipa包输出地址
  output_name: project.ipa_name, #ipa包的名字
  silent: false) # 编译Action
end
```

用 gym action 构建一个自定义的、带参数的完整的构建过程了。我们可以看到，这里的参数是具体的一个 project 对象。当然，这里还有一个叫作 output_directory 的参数，你可以利用这个参数把构建的 ipa 包放到内部的下载地址。

### 提升移动APP的交付效率

从开发人员的角度看，提升效率最好的方法就是 2 个字：解耦。落到技术实现上来说，就是通过组件化形成合理的开发框架

组件化是指，解耦复杂系统时将多个功能模块拆分、重组的过程。对于移动 App 来说可以横向地按功能模块进行组件化；也可以纵向地按照架构层次进行组件化。当然目前移动 App 的架构往往都已经比较复杂了，所以通常都是两者混合的模式。

组件化带来的好处包括：

1. **方便拆分代码仓库，降低分支管理难度，提高开发并行度。**如果一个巨大的 App 的所有代码都集中在同一个代码仓库中，而所有的并行开发功能又都会形成一个个的功能分支的话，它们之间相互的影响将是难以想象的。其实，任何一个代码仓库，当需要管理的并行分支超过 10 个时，都会让人头痛。所以，组件化的好处就是，对整个项目进行解耦，把不相干的功能组件从代码仓库这个层面进行隔离，以免互相影响。
2. **组件可以多版本存在，通过依赖快速选取所需版本。**所有的组件都可以同时发布多个版本，发布的形式可以是代码包、二进制组件等等。这样做的好处是，对于组件的提供方和依赖方来说，只需要通过版本控制就能管理或者选取自己需要的组件功能，这种方式更符合编程习惯，也降低了减少沟通成本。
3. **专业分工，形成更优的组织结构。**一旦实施组件化，各种更专业的通用组建会慢慢形成（比如网络处理、图片处理、语音处理等等），而这些更专业的组件，也会渐渐地由更专业的人或团队进行开发和维护，专业的分工使得研发效率得到进一步提升。所以，组件化其实就是通过专业分工，提升了整个组织的开发效率。

当然，组件化并非完美无瑕，它同时也会引起一些问题，比如：

1. 组件间的依赖问题。由于多组件、多版本的存在，加之它们之间的传递依赖，所以组件化之后的依赖管理问题不容小觑。
2. 组件间的兼容问题。兼容性问题，是由组件间的依赖问题引发的，由此组件的发布管理也会成为瓶颈：组件间到底要不要兼容？出现了不兼容的情况，应该怎么办？

### 如何提升构建效率？

从目前业界流行的处理方法来看，提升构建阶段的效率，可以从**扁平化依赖管理和二进制交付**两个维度解决。

#### 第一，扁平化依赖管理

<img src="https://static001.geekbang.org/resource/image/24/87/24a6ebb48588b8a3660d0e357b2db187.png" alt="img" style="zoom:50%;" />

由传递依赖带来的不确定性，是我们经常会遇见并非常讨厌的组件依赖形式。因为发现和处理的成本都很高。

一个移动 App 可以拆分出十几到几十个组件。大型的移动 App，如淘宝、美团，甚至可以拆分出几百个组件。要保证这么多组件间依赖传递的准确性，其难度非常大。所以，为了解决这个问题，**业界现在普遍直接采用扁平化的依赖管理方式，减少甚至去除传递依赖，以此避免组件、版本冲突的问题。**

<img src="https://static001.geekbang.org/resource/image/d7/bc/d7892bb8128b939b28117fa5e05bfbbc.png" alt="img" style="zoom:50%;" />

#### 第二，二进制交付

解决了组件的依赖问题之后，我们需要再考虑的问题是，如何才能提高编译速度

传统的移动 App 组件集成及编译的方式如图 3 所示。组件先以源码的方式集成到目标项目，然后对整个项目进行编译。如果组件比较多的话，采用这种方式的编译时间会非常长。有时，甚至要编译 1 个多小时。显然，我们不会接受这种低效的集成与编译方式。

使用二进制包的方式，可以帮我们大幅提升移动 App 的编译速度。而且，因为有了中间交付物，我们可以采用与后端服务一样的方式，在本地缓存需要依赖的组件，进一步加速编译过程。

### 如何提升测试效率？

1. **代码静态扫描工具。**所以针对移动 App 的代码静态扫描，目前多数大厂都采用自研的方式，定制静态代码扫描工具。另外，针对移动 App 开源的静态代码扫描工具，如 Lint 等，已经可以满足小团队的使用了。

2. **UI 自动化测试。**这部分的关注点是成本和收益比，你我都清楚，UI 自动化测试的脚本维护成本高，导致其难以被大规模使用。所以，针对重要的模块和组件，有计划地使用 UI 自动化测试是重中之重。

3. **自动 Monkey 测试。**Monkey 是一款非常好用的探索性测试工具，可以大幅提升测试效率，有效解决手工测试的盲点。iOS 系统的测试，由于系统限制比较多，所以可以在模拟器上执行 Monkey 的方式。

当然在测试过程中，合理地搭配监控工具，如性能监控、白屏检测等，可以起到更好的作用。

### 如何提升发布效率？

提高分发稳定性的一个方法就是，减少分发时更新的内容，并同时减少更新的时间。而对于移动 App 来说，静态资源包的差分发布就是一个优化方案。













