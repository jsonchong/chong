> 假如有一只青蛙，一次可以跳上1级台阶，也可以跳2级台阶，请问青蛙上一个n级台阶一共有多少种跳法？

看似简单，其实内含杀机。如果面试者在面试种遇到这个题，大部分同学肯定是没思路的。当然如果之前就遇到过，应该没什么问题，因为这道题也很简单啊，为什么呢？请听我为大家分析

1. 假如现在台阶只有1级，n = 1，那么这只青蛙就在只有1种跳法：1（1代表一次跳1级台阶）也就是f(1) = 1种跳法
2. 假如现在台阶只有2级，n = 2，那么这只青蛙可以有2种跳法：1 1、2（2代表一次跳2级台阶），也就是f(2) = 2种跳法
3. 假如现在台阶有3级，n = 3，青蛙可以有几种跳法呢？
   假如青蛙先跳了1级台阶，还剩下2级台阶，那它还有几种跳法呢，通过第2个情况分析知道有2种跳法；假如青蛙先跳了2级台阶，根据第1个情况分析知道有1种跳法，所以这时候得出f(3) = 2 + 1种方法
4. 假如现在台阶有4级，n = 4，我们利用上面的规律继续分析可得：f(4) = 3 + 2

综上所述，我们得出其实这个算法就是一个斐波那契数列问题，公式如下：

- n = 1, f(1) = 1
- n = 2, f(2) = 2
- n > 2, f(n) = f(n -1) + f(n -2)

一个递归搞定：

```java
 private static long fibonacciByRecursive(int n) {
        if (n <= 0) {
            return 0;
        }

        if (n == 1) {
            return 1;
        }

        if (n == 2) {
            return 2;
        }
        return fibonacciByRecursive(n - 1) + fibonacciByRecursive(n - 2);
    }
```

可以试试输入n = 100 试试？或者输入n = 50 试试？于是你就发现你的递归就不行了，需要很久才能得到结果，甚至程序崩溃。

假如n = 5：

- f(5)=f(4)+f(3)
- f(4)=f(3)+f(2)
- f(3)=f(2)+f(1)
- f(2)=f(1)+f(0)

从这写等式中你可以看出，计算f(5)就要先计算f(4)和f(3)，而计算f(4)就要先计算f(3)和f(2)，然后f(3)要被算两次，并要计算f(2) + f(1)，存在很多重复计算，同学试想一下下，如果n = 10会存在多少重复计算呢？n = 100呢？

所以在递归解法中存在大量的重复计算导致了程序变得很慢，效率底下，甚至无法完成任务！

那我们要怎么解决斐波那契数列问题呢？

假如n = 5，计算f(5):我们可以先计算出f(0)和f(1)，然后计算出f(2) = f(1) + f(0)，然后f(3) = f(2) + f(1)，……最后得出f(5) = f(4) + f(3)。这样从小往大计算，每个都只用计算一次，极大的提高了程序的执行效率！所以这个问题的终极解法就是：使用循环，从小往大开始相加。代码如下：

```java
private static long fibonacciNotRecursive(int n) {
        int[] result = {0, 1, 2};
        if (n <= 2) {
            return result[n];
        }

        long fibOne = 2;
        long fibNTwo = 1;
        long fibN = 0;
        for (int i = 3; i <= n; i++) {
            fibN = fibOne + fibNTwo;
            fibNTwo = fibOne;
            fibOne = fibN;
        }
        return fibN;
    }
```

























