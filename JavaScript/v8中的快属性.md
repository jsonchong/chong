从 JavaScript 的角度来看属性只有少数的区别。JavaScript 对象通常跟字典（dictionaris）差不多，以字符串为键，任意对象为值

然而，在底层 V8 的确依赖了一些不同的属性表示方式，这是出于性能和内存考虑的。本文我们将解释 V8 如何在提供快属性访问的同时支持动态添加属性。理解属性如何工作对解释 V8 [内联缓存](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html)之类的优化原理是必不可少的。

### 命名属性与元素

首先我们来分析一个简单的对象 `{a: "foo", b: "bar"}`。这个对象有两个命名属性，`"a"` 和 `"b"`，没有任何整数索引作属性名。数组索引属性（array-indexed properties），常叫元素（elements），在数组中非常重要。比如数组 `["foo", "bar"]` 有两个数组索引属性：0 与值 "foo" ，和 1 与值 "bar"。 这是 V8 如何处理属性的第一个主要区别。

![img](https://v8.dev/_img/fast-properties/jsobject.png)

元素和属性被保存在两个独立的数据结构中。两者的使用方式通常不一样，故这能让添加和访问属性或元素更加高效。

命名属性也是通过类似的方式存在另外的**数组**中。但是，跟元素不同，**我们不能简单地通过键来推断出它们在属性数组中的位置，我们需要一些额外的元数据。在 V8 中每个 JavaScript 对象都关联了一个隐藏类（HiddenClasses）**。隐藏类保存了对象的形状信息，以及从**属性名称到属性索引的映射**。**复杂的使用情况下我们有时会用字典来存属性而不是简单的数组**

### 隐藏类和描述符数组

隐藏类保存了与对象相关的元信息，包括对象上的属性数和对象原型的引用。隐藏类充当了对象形状的标识符，因此是 V8 优化编译器和内联缓存非常重要的组成部分。

![img](https://v8.dev/_img/fast-properties/hidden-class.png)

在 V8 中，JavaScript 对象的第一个字段指向隐藏类（事实上，任何在 V8 堆上且由垃圾收集器管理的对象都是这种情况）。在属性中，**最重要的信息是第三位字段，它保存了属性数以及描述符数组的指针**。**描述符数组包含了有关命名属性的信息，例如名称本身以及值保存的位置。**

每次添加新属性时，对象的隐藏类都会被更改。在引擎的底层，V8 创建了一个将隐藏类链接在一起的转换树（transiton tree）

![img](https://v8.dev/_img/fast-properties/transitions.png)

**总结：**

具有相同结构的对象（相同顺序相同属性）具有相同的隐藏类。

默认情况下，每添加新的命名属性都会导致一个新的隐藏类被创建

添加数组索引属性不会创建新的隐藏类。

### 三种不同的命名属性

属性有两种基本类型：命名和索引。以下部分先介绍命名属性。

一个简单的对象如 `{a：1，b：2}` 在 V8 中可以有多种内部表示。虽然 JavaScript 对象在外部看来或多或少类似于简单的字典，但 V8 试图避免使用字典，因为它们妨碍了某些优化，如[内联缓存](https://en.wikipedia.org/wiki/Inline_caching)

**V8 支持所谓的对象内属性（in-object properties），指这些属性直接存储在对象本身上。**它们在 V8 可用的属性中是最快的，因为它们不需要间接层就可以访问。对象内属性的数量由对象的初始大小预先确定。如果添加的属性超出了对象分配的空间，则它们将被保存在属性存储中。属性存储多了一层间接层，但可以自由地扩容。

**快属性与慢属性**：我们将保存在线性属性存储中的属性定义为“快”。只需通过属性存储中的索引即可访问快属性。要从属性名称获取属性存储中的实际位置，我们必须查看隐藏类上的描述符数组

但是，如果从对象中添加和删除大量属性，则可能会产生大量时间和内存开销来维护描述符数组和隐藏类。因此 V8 还支持所谓的慢属性。**带慢属性的对象内部会有独立的词典作为属性存储。所有的属性元信息不再保存在隐藏类的描述符数组中，而是直接保存在属性字典中。因此无需更新隐藏类即可添加和删除属性。由于内联缓存不适用于字典属性，故后者通常比快属性慢。**

![img](https://v8.dev/_img/fast-properties/fast-vs-slow-properties.png)

### 元素与数组索引属性

我们一直在讨论命名属性，而忽略了常用于数组的整数索引属性。处理整数索引属性并不比命名属性简单。尽管所有索引属性都是在元素存储中单独保存

**挤满的还是带空隙的元素：** V8 做的第一个主要区分看是元素后备存储（elements backing store）是挤满的（packed）还是带空隙的（holey）。当索引元素被删除，又或者如，没有被定义，后备存储中就会出现空隙。如一个简单的例子 `[1,,3]`，其中的第二个条目就是一个空隙。以下示例说明了此问题：

```javascript
const o = ['a', 'b', 'c'];
console.log(o[1]);          // 打印 'b'.

delete o[1];                // 在元素存储中引入空隙
console.log(o[1]);          // 打印 'undefined'，属性 1 不存在
o.__proto__ = {1: 'B'};     // 在原型中定义属性 1

console.log(o[0]);          // 打印 'a'.
console.log(o[1]);          // 打印 'B'.
console.log(o[2]);          // 打印 'c'.
console.log(o[3]);          // 打印 undefined
```

![img](https://v8.dev/_img/fast-properties/hole.png)

简而言之，如果接收方（receiver）上没有发现属性，我们就必须沿着原型链继续查找。鉴于元素是内部独立的（比如，我们不会在隐藏类上保存有关当前索引属性的信息），我们需要一个特殊值，称为 _hole，来标记不存在的属性。这对于数组函数的性能是至关重要的。如果我们知道没有空隙，即元素存储是挤满的，我们就可以直接在当前域执行操作而无需沿着原型链做昂贵的查找。

**快元素还是字典元素：** V8 对元素做的第二个主要区分是看它们是在快速模式还是字典模式。快元素是简单的虚拟机内部数组，其中的属性索引映射到元素存储中的索引。然而，这种简单的表示对于非常大的稀疏/带空隙的数组而言是相当浪费的，其中只有很少的条目被占用。在这种情况下，我们使用基于字典的表示来节省内存，但代价是访问速度稍慢：

```javascript
const sparseArray = [];
sparseArray[9999] = 'foo'; // 创建了一个基于字典元素的数组
```

在这个例子中，开辟一个包含一万条目的完整数组会相当浪费。相反，V8 会创建一个字典来存储键-值-描述符三元组。在这个例子中，键是 `'9999'`，值是 `'foo'`，默认描述符被使用。由于我们没有办法在隐藏类上保存描述符的详细信息，故只要你使用了自定义描述符去定义索引属性，V8 就会采用慢元素：

```javascript
const array = [];
Object.defineProperty(array, 0, {value: 'fixed' configurable: false});
console.log(array[0]);      // 打印 'fixed'。
array[0] = 'other value';   // 不能重写索引 0。
console.log(array[0]);      // 依然打印 'fixed'。
```

在这个例子中，我们在数组上添加了一个不可配置的属性。该信息保存在慢元素字典三元组的描述符部分中。需要注意的是，在带有慢元素的对象上数组函数的执行速度会慢很多。









